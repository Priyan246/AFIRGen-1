# AFIRGen Database Configuration

## Database System: MySQL 8.0

AFIRGen uses **MySQL 8.0** as its primary database for storing FIR records and related data.

## Database Schema

### Tables

#### `fir_records`
Stores all FIR (First Information Report) records generated by the system.

```sql
CREATE TABLE IF NOT EXISTS fir_records (
    id INT AUTO_INCREMENT PRIMARY KEY,
    fir_number VARCHAR(100) UNIQUE NOT NULL,
    session_id VARCHAR(100),
    complaint_text TEXT,
    fir_content TEXT,
    violations_json LONGTEXT,
    status ENUM('pending', 'finalized') DEFAULT 'pending',
    finalized_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
```

**Columns:**
- `id`: Auto-incrementing primary key
- `fir_number`: Unique FIR identifier (format: FIR-{session_id}-{timestamp})
- `session_id`: Reference to the processing session
- `complaint_text`: Original complaint/transcript text
- `fir_content`: Generated FIR document content
- `violations_json`: JSON array of identified legal violations (BNS sections)
- `status`: FIR status (pending or finalized)
- `finalized_at`: Timestamp when FIR was finalized
- `created_at`: Record creation timestamp

## Configuration

### Environment Variables

The following environment variables configure the MySQL connection:

```bash
MYSQL_HOST=mysql          # Database host (use 'mysql' for Docker, 'localhost' for local)
MYSQL_PORT=3306           # MySQL port (default: 3306)
MYSQL_USER=root           # Database user
MYSQL_PASSWORD=password   # Database password
MYSQL_DB=fir_db          # Database name
```

### Docker Compose Configuration

The `docker-compose.yaml` includes a MySQL 8.0 service with:
- Persistent volume (`mysql_data`) for data storage
- Health check to ensure database is ready before app starts
- Configurable credentials via environment variables

### Connection Pool

The application uses MySQL connection pooling for efficient database access:

```python
pool = mysql.connector.pooling.MySQLConnectionPool(
    pool_name="fir_pool",
    host=MYSQL_HOST,
    port=MYSQL_PORT,
    user=MYSQL_USER,
    password=MYSQL_PASSWORD,
    database=MYSQL_DB,
    charset="utf8mb4",
    autocommit=True,
    pool_size=10,
    pool_reset_session=True,
    pool_timeout=30
)
```

**Pool Configuration:**
- Pool size: 10 connections
- Auto-commit enabled
- Session reset on connection return
- 30-second connection timeout

## Session Management

In addition to MySQL, the system uses **SQLite** for session persistence:

- **File:** `sessions.db`
- **Purpose:** Store temporary session state, validation history, and workflow progress
- **Cleanup:** Automatic expiration of sessions after timeout (default: 1 hour)

### Sessions Table

```sql
CREATE TABLE IF NOT EXISTS sessions (
    session_id TEXT PRIMARY KEY,
    state TEXT,
    status TEXT,
    created_at TEXT,
    last_activity TEXT,
    validation_history TEXT
)
```

## Database Initialization

The database tables are automatically created on application startup if they don't exist. No manual migration is required for initial setup.

## Automated Backup System

AFIRGen includes an automated backup system that runs every 6 hours:

### Features
- **Automated Schedule**: Backups run at 00:00, 06:00, 12:00, 18:00 UTC
- **Dual Database Support**: Backs up both MySQL and SQLite sessions
- **Compression**: All backups are gzip-compressed
- **Retention Policy**: Automatically removes backups older than 7 days (configurable)
- **Docker Integration**: Runs as a separate service

### Quick Start

```bash
# Start backup service
docker-compose up -d backup

# View backup logs
docker-compose logs -f backup

# Manual backup
docker exec afirgen-backup python3 /app/backup_database.py

# List backups
docker exec afirgen-backup ls -lh /app/backups/
```

### Configuration

Set retention period in `.env`:
```bash
BACKUP_RETENTION_DAYS=7  # Days to keep backups
```

### Documentation

- **Full Guide**: See `DATABASE-BACKUP-GUIDE.md` for complete documentation
- **Quick Reference**: See `DATABASE-BACKUP-QUICK-REFERENCE.md` for common commands
- **Testing**: Run `python3 test_backup.py` to validate backup system

### Backup Files

- MySQL: `mysql_backup_YYYYMMDD_HHMMSS.sql.gz`
- Sessions: `sessions_backup_YYYYMMDD_HHMMSS.db.gz`

### Restoration

See `DATABASE-BACKUP-GUIDE.md` for detailed restoration procedures.

## Migration to AWS RDS

For AWS deployment, replace the Docker MySQL service with AWS RDS:

1. Create RDS MySQL 8.0 instance
2. Update environment variables:
   ```bash
   MYSQL_HOST=<rds-endpoint>
   MYSQL_PORT=3306
   MYSQL_USER=<rds-username>
   MYSQL_PASSWORD=<rds-password>
   MYSQL_DB=fir_db
   ```
3. Ensure security groups allow ECS tasks to connect to RDS
4. Enable automated backups and Multi-AZ for production

## Troubleshooting

### Connection Issues

**Problem:** Application can't connect to MySQL

**Solutions:**
1. Verify MySQL container is running: `docker ps`
2. Check MySQL logs: `docker logs <mysql-container-id>`
3. Verify environment variables are set correctly
4. Ensure MySQL is ready (health check passing)
5. Check network connectivity between containers

### Character Encoding

The system uses `utf8mb4` charset to support:
- Unicode characters
- Emojis
- Multi-language text (Hindi, English, etc.)

### Performance Tuning

For high-load scenarios:
1. Increase connection pool size
2. Add database indexes on frequently queried columns
3. Enable MySQL query cache
4. Use read replicas for scaling reads

## Security Best Practices

1. **Never use default passwords in production**
2. Use strong passwords (16+ characters, mixed case, numbers, symbols)
3. Restrict MySQL port (3306) access to application containers only
4. Enable SSL/TLS for MySQL connections in production
5. Use AWS Secrets Manager for credential management in AWS deployments
6. Regularly update MySQL to latest 8.0.x version for security patches
